#!/usr/bin/env python3
"""
Certificate Generation Script

This script automates the generation of certificates for mTLS authentication
as described in the certificates/README.md file.

The script creates:
- Root CA certificate and key
- Client certificate and key
- Server certificate and key
- P12 bundle for client authentication
- Truststore bundle

All certificates are generated in the certificates/ directory within this script's location.
"""

import argparse
import base64
import secrets
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Optional, Tuple

import boto3
from aws_config_manager import create_logger
from cryptography.fernet import Fernet

logger = create_logger(logger_name="aws_config", log_level="INFO")


def run_openssl_command(command: list[str], description: str) -> Tuple[bool, str]:
    """
    Run an OpenSSL command and return success status and output.

    Args:
        command: List of command arguments
        description: Description of what the command does

    Returns:
        Tuple of (success: bool, output: str)
    """
    try:
        logger.info(f"Running: {description}")
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        logger.info(f"Success: {description}")
        return True, result.stdout
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed: {description}")
        logger.error(f"Error: {e.stderr}")
        return False, e.stderr


def create_certificates_directory(base_path: Path) -> Path:
    """
    Create the certificates directory if it doesn't exist.

    Args:
        base_path: Base path where certificates directory should be created

    Returns:
        Path to the certificates directory
    """
    cert_dir = base_path / "certificates"
    cert_dir.mkdir(exist_ok=True)
    logger.info(f"Created certificates directory: {cert_dir}")
    return cert_dir


def generate_random_secrets() -> dict[str, str]:
    """
    Generate random values for required secrets.

    Returns:
        Dictionary containing generated secret values
    """
    return {
        "CALENDAR_BEARER_TOKEN": secrets.token_urlsafe(32),
        "CALENDAR_TOKEN_ENCRYPTION_KEY": Fernet.generate_key().decode(),
        "CALENDAR_MCP_CLIENT_P12_PASSWORD": secrets.token_urlsafe(16),
        "CALENDAR_HMAC_SECRET": secrets.token_urlsafe(32),
    }


def create_environment_script(
    cert_dir: Path, secrets_dict: dict[str, str], p12_password: str
) -> bool:
    """
    Create a shell script to set environment variables for local development.

    Args:
        cert_dir: Directory containing certificates
        secrets_dict: Dictionary of generated secrets
        p12_password: P12 password used for certificate generation

    Returns:
        Success status
    """
    try:
        env_script_path = cert_dir / "set_env.sh"
        zshrc_script_path = cert_dir / "append_to_zshrc.sh"

        # Get base64 content of certificates
        ca_cert_b64 = ""
        client_p12_b64 = ""

        ca_cert_b64_path = cert_dir / "ca.crt.b64"
        client_p12_b64_path = cert_dir / "client.p12.b64"

        if ca_cert_b64_path.exists():
            with open(ca_cert_b64_path, "r") as f:
                ca_cert_b64 = f.read().strip()

        if client_p12_b64_path.exists():
            with open(client_p12_b64_path, "r") as f:
                client_p12_b64 = f.read().strip()

        # Create environment script (for sourcing)
        script_content = f"""#!/bin/bash
# Environment variables for local development
# Generated by generate_certs.py

# Base64-encoded certificates (for Calendar Agent and test client)
export CALENDAR_MCP_CA_CERT_B64="{ca_cert_b64}"
export CALENDAR_MCP_CLIENT_P12="{client_p12_b64}"

# Generated secrets
export CALENDAR_BEARER_TOKEN="{secrets_dict["CALENDAR_BEARER_TOKEN"]}"
export CALENDAR_TOKEN_ENCRYPTION_KEY="{secrets_dict["CALENDAR_TOKEN_ENCRYPTION_KEY"]}"
export CALENDAR_MCP_CLIENT_P12_PASSWORD="{p12_password}"

# MCP server URL
export CALENDAR_MCP_URL="https://localhost:8000"

# Timezone
export CALENDAR_MCP_DEFAULT_TZ="Europe/London"

echo "Environment variables set for local development"
echo "P12 Password: {p12_password}"
"""

        # Create zshrc append script
        zshrc_content = f"""#!/bin/bash
# Append environment variables to ~/.zshrc
# Generated by generate_certs.py

ZSH_CONFIG="$HOME/.zshrc"
BACKUP_FILE="$HOME/.zshrc.backup.$(date +%Y%m%d_%H%M%S)"

# Check if any Calendar MCP variables already exist in .zshrc
if grep -q "CALENDAR_MCP_\\|CALENDAR_BEARER_TOKEN\\|CALENDAR_TOKEN_ENCRYPTION_KEY" "$ZSH_CONFIG" 2>/dev/null; then
    echo "Calendar MCP variables already exist in ~/.zshrc"
    echo "Backing up current .zshrc to $BACKUP_FILE"
    cp "$ZSH_CONFIG" "$BACKUP_FILE"

    # Remove existing calendar mcp variables (including CALENDAR_BEARER_TOKEN and CALENDAR_TOKEN_ENCRYPTION_KEY)
    grep -v "CALENDAR_MCP_\\|CALENDAR_BEARER_TOKEN\\|CALENDAR_TOKEN_ENCRYPTION_KEY" "$ZSH_CONFIG" > "$ZSH_CONFIG.tmp" && mv "$ZSH_CONFIG.tmp" "$ZSH_CONFIG"
    echo "Removed existing Calendar MCP variables"
fi

# Append new variables
cat >> "$ZSH_CONFIG" << 'EOF'

# Calendar MCP Environment Variables
# Generated by generate_certs.py on $(date)
export CALENDAR_MCP_CA_CERT_B64="{ca_cert_b64}"
export CALENDAR_MCP_CLIENT_P12="{client_p12_b64}"
export CALENDAR_BEARER_TOKEN="{secrets_dict["CALENDAR_BEARER_TOKEN"]}"
export CALENDAR_TOKEN_ENCRYPTION_KEY="{secrets_dict["CALENDAR_TOKEN_ENCRYPTION_KEY"]}"
export CALENDAR_MCP_CLIENT_P12_PASSWORD="{p12_password}"
export CALENDAR_MCP_URL="https://localhost:8000"
export CALENDAR_MCP_DEFAULT_TZ="Europe/London"
EOF

echo "Environment variables appended to ~/.zshrc"
echo "P12 Password: {p12_password}"
echo ""
echo "To apply changes, run: source ~/.zshrc"
echo "Or restart your terminal"
"""

        # Write both scripts
        with open(env_script_path, "w") as f:
            f.write(script_content)

        with open(zshrc_script_path, "w") as f:
            f.write(zshrc_content)

        # Make scripts executable
        env_script_path.chmod(0o755)
        zshrc_script_path.chmod(0o755)

        logger.info(f"Created environment script: {env_script_path}")
        logger.info(f"Created zshrc append script: {zshrc_script_path}")
        return True

    except Exception as e:
        logger.error(f"Failed to create environment scripts: {e}")
        return False


def generate_ca_certificate(
    cert_dir: Path, ca_name: str = "CalendarMCPDevRootCA"
) -> Tuple[bool, Optional[Path], Optional[Path]]:
    """
    Generate the root CA certificate and key.

    Args:
        cert_dir: Directory to store certificates
        ca_name: Common name for the CA

    Returns:
        Tuple of (success: bool, ca_crt_path: Optional[Path], ca_key_path: Optional[Path])
    """
    ca_key_path = cert_dir / "ca.key"
    ca_crt_path = cert_dir / "ca.crt"

    # Generate CA certificate
    command = [
        "openssl",
        "req",
        "-x509",
        "-new",
        "-nodes",
        "-sha256",
        "-days",
        "365",
        "-subj",
        f"/CN={ca_name}",
        "-newkey",
        "rsa:2048",
        "-keyout",
        str(ca_key_path),
        "-out",
        str(ca_crt_path),
    ]

    success, _ = run_openssl_command(command, "Generate CA certificate")
    if not success:
        return False, None, None

    # Base64 encode the CA certificate
    ca_crt_b64_path = cert_dir / "ca.crt.b64"
    try:
        with open(ca_crt_path, "rb") as f:
            ca_crt_content = f.read()

        with open(ca_crt_b64_path, "wb") as f:
            f.write(base64.b64encode(ca_crt_content))

        logger.info(f"Created base64 encoded CA certificate: {ca_crt_b64_path}")
    except Exception as e:
        logger.error(f"Failed to create base64 encoded CA certificate: {e}")
        return False, None, None

    return True, ca_crt_path, ca_key_path


def generate_client_certificate(
    cert_dir: Path, ca_crt_path: Path, ca_key_path: Path, client_name: str = "agent-123"
) -> Tuple[bool, Optional[Path], Optional[Path]]:
    """
    Generate client certificate and key.

    Args:
        cert_dir: Directory to store certificates
        ca_crt_path: Path to CA certificate
        ca_key_path: Path to CA key
        client_name: Common name for the client certificate

    Returns:
        Tuple of (success: bool, client_crt_path: Optional[Path], client_key_path: Optional[Path])
    """
    client_key_path = cert_dir / "client.key"
    client_csr_path = cert_dir / "client.csr"
    client_crt_path = cert_dir / "client.crt"

    # Generate client key and CSR
    command = [
        "openssl",
        "req",
        "-new",
        "-newkey",
        "rsa:2048",
        "-nodes",
        "-subj",
        f"/CN={client_name}",
        "-keyout",
        str(client_key_path),
        "-out",
        str(client_csr_path),
    ]

    success, _ = run_openssl_command(command, "Generate client key and CSR")
    if not success:
        return False, None, None

    # Sign the client certificate with CA
    command = [
        "openssl",
        "x509",
        "-req",
        "-in",
        str(client_csr_path),
        "-CA",
        str(ca_crt_path),
        "-CAkey",
        str(ca_key_path),
        "-CAcreateserial",
        "-out",
        str(client_crt_path),
        "-days",
        "60",
        "-sha256",
    ]

    success, _ = run_openssl_command(command, "Sign client certificate with CA")
    if not success:
        return False, None, None

    return True, client_crt_path, client_key_path


def generate_server_certificate(
    cert_dir: Path, ca_crt_path: Path, ca_key_path: Path, server_name: str = "localhost"
) -> Tuple[bool, Optional[Path], Optional[Path]]:
    """
    Generate server certificate and key.

    Args:
        cert_dir: Directory to store certificates
        ca_crt_path: Path to CA certificate
        ca_key_path: Path to CA key
        server_name: Common name for the server certificate

    Returns:
        Tuple of (success: bool, server_crt_path: Optional[Path], server_key_path: Optional[Path])
    """
    server_key_path = cert_dir / "server.key"
    server_csr_path = cert_dir / "server.csr"
    server_crt_path = cert_dir / "server.crt"
    server_ext_path = cert_dir / "server.ext"

    # Generate server private key
    command = ["openssl", "genrsa", "-out", str(server_key_path), "2048"]
    success, _ = run_openssl_command(command, "Generate server private key")
    if not success:
        return False, None, None

    # Generate server CSR
    command = [
        "openssl",
        "req",
        "-new",
        "-key",
        str(server_key_path),
        "-out",
        str(server_csr_path),
        "-subj",
        f"/CN={server_name}",
    ]
    success, _ = run_openssl_command(command, "Generate server CSR")
    if not success:
        return False, None, None

    # Create server extension file for SAN
    try:
        with open(server_ext_path, "w") as f:
            f.write("subjectAltName = @alt_names\n")
            f.write("[alt_names]\n")
            f.write(f"DNS.1 = {server_name}\n")
        logger.info(f"Created server extension file: {server_ext_path}")
    except Exception as e:
        logger.error(f"Failed to create server extension file: {e}")
        return False, None, None

    # Sign server certificate with CA
    command = [
        "openssl",
        "x509",
        "-req",
        "-in",
        str(server_csr_path),
        "-CA",
        str(ca_crt_path),
        "-CAkey",
        str(ca_key_path),
        "-CAcreateserial",
        "-out",
        str(server_crt_path),
        "-days",
        "60",
        "-sha256",
        "-extfile",
        str(server_ext_path),
    ]
    success, _ = run_openssl_command(command, "Sign server certificate with CA")
    if not success:
        return False, None, None

    return True, server_crt_path, server_key_path


def create_truststore(cert_dir: Path, ca_crt_path: Path) -> bool:
    """
    Create truststore bundle (just the CA certificate).

    Args:
        cert_dir: Directory to store certificates
        ca_crt_path: Path to CA certificate

    Returns:
        Success status
    """
    truststore_path = cert_dir / "truststore.pem"

    try:
        with open(ca_crt_path, "r") as ca_file:
            ca_content = ca_file.read()

        with open(truststore_path, "w") as truststore_file:
            truststore_file.write(ca_content)

        logger.info(f"Created truststore: {truststore_path}")

        # Also copy truststore to src/calendar_agent_api/certificates/
        try:
            src_root = cert_dir.parent.parent  # ../ (up from certificates/ to src/)
            target_dir = src_root / "calendar_agent_api" / "certificates"
            target_dir.mkdir(parents=True, exist_ok=True)
            target_path = target_dir / "truststore.pem"
            shutil.copy2(truststore_path, target_path)
            logger.info(f"Copied truststore to: {target_path}")
        except Exception as copy_err:
            # Do not fail the truststore creation if copy fails; just log it
            logger.warning(
                f"Failed to copy truststore to agent_api certificates dir: {copy_err}"
            )

        return True
    except Exception as e:
        logger.error(f"Failed to create truststore: {e}")
        return False


def create_p12_bundle(
    cert_dir: Path,
    client_crt_path: Path,
    client_key_path: Path,
    p12_password: str,
) -> Tuple[bool, Optional[Path]]:
    """
    Create P12 bundle from client certificate and key.

    Args:
        cert_dir: Directory to store certificates
        client_crt_path: Path to client certificate
        client_key_path: Path to client key
        p12_password: Password for the P12 bundle

    Returns:
        Tuple of (success: bool, p12_b64_path: Optional[Path])
    """
    p12_path = cert_dir / "client.p12"
    p12_b64_path = cert_dir / "client.p12.b64"

    # Create P12 bundle
    command = [
        "openssl",
        "pkcs12",
        "-export",
        "-out",
        str(p12_path),
        "-inkey",
        str(client_key_path),
        "-in",
        str(client_crt_path),
        "-name",
        "mcp-client",
        "-passout",
        f"pass:{p12_password}",
    ]

    success, _ = run_openssl_command(command, "Create P12 bundle")
    if not success:
        return False, None

    # Base64 encode the P12 bundle
    try:
        with open(p12_path, "rb") as f:
            p12_content = f.read()

        with open(p12_b64_path, "wb") as f:
            f.write(base64.b64encode(p12_content))

        logger.info(f"Created base64 encoded P12 bundle: {p12_b64_path}")
        return True, p12_b64_path
    except Exception as e:
        logger.error(f"Failed to create base64 encoded P12 bundle: {e}")
        return False, None


def copy_server_certificates_to_mcp(cert_dir: Path, script_dir: Path) -> bool:
    """
    Copy server certificates to the calendar_mcp directory for local development.
    These certificates are not copied into the AWS MCP deployment, they are used for
    mutual TLS testing on localhost for local development.

    Args:
        cert_dir: Directory containing certificates
        script_dir: Directory where this script is located

    Returns:
        Success status
    """
    try:
        # Define source files
        server_crt = cert_dir / "server.crt"
        server_key = cert_dir / "server.key"
        ca_crt = cert_dir / "ca.crt"

        # Define destination directory
        mcp_dir = script_dir.parent / "calendar_mcp"
        certs_dir = mcp_dir / "certificates"

        # Check if source files exist
        if not server_crt.exists():
            logger.error(f"Server certificate not found: {server_crt}")
            return False
        if not server_key.exists():
            logger.error(f"Server key not found: {server_key}")
            return False
        if not ca_crt.exists():
            logger.error(f"CA certificate not found: {ca_crt}")
            return False

        # Create destination directories if they don't exist
        mcp_dir.mkdir(exist_ok=True)
        certs_dir.mkdir(exist_ok=True)

        # Copy files
        import shutil

        shutil.copy2(server_crt, certs_dir / "server.crt")
        shutil.copy2(server_key, certs_dir / "server.key")
        shutil.copy2(ca_crt, certs_dir / "ca.crt")

        logger.info(f"Copied server certificates to: {certs_dir}")
        logger.info("  - server.crt (server certificate)")
        logger.info("  - server.key (server private key)")
        logger.info("  - ca.crt (CA certificate)")
        return True

    except Exception as e:
        logger.error(f"Failed to copy server certificates: {e}")
        return False


def cleanup_intermediate_files(cert_dir: Path) -> None:
    """
    Clean up intermediate files that are not needed after certificate generation.

    Args:
        cert_dir: Directory containing certificates
    """
    files_to_remove = ["client.csr", "server.csr", "server.ext", "ca.srl"]

    for filename in files_to_remove:
        file_path = cert_dir / filename
        if file_path.exists():
            try:
                file_path.unlink()
                logger.info(f"Removed intermediate file: {file_path}")
            except Exception as e:
                logger.warning(f"Failed to remove {file_path}: {e}")


class CertificateManager:
    """Manages certificate generation and deployment."""

    def __init__(
        self,
        ca_name: str = "CalendarMCPDevRootCA",
        client_name: str = "CalendarMCPClient",
        server_name: str = "CalendarMCPServer",
        p12_password: str | None = None,
        copy_to_mcp: bool = True,
        cleanup: bool = False,
    ) -> None:
        """Initialize the CertificateManager with specific values."""
        self.ca_name = ca_name
        self.client_name = client_name
        self.server_name = server_name
        self.copy_to_mcp = copy_to_mcp
        self.cleanup = cleanup

        self.script_dir = Path(__file__).parent
        self.cert_dir = create_certificates_directory(self.script_dir)
        self.secrets_dict = generate_random_secrets()

        # Use provided P12 password or generate a random one
        if p12_password:
            self.p12_password = p12_password
            logger.info("Using provided P12 password")
        else:
            self.p12_password = self.secrets_dict["CALENDAR_MCP_CLIENT_P12_PASSWORD"]
            logger.info(f"Generated P12 password: {self.p12_password}")

    def update_mtls_truststore(
        self, domain: str, bucket: str, key: str, file_path: str
    ) -> None:
        """
        Update mTLS truststore by uploading a new truststore file to S3 and updating API Gateway.

        Args:
            domain: Domain name for the API Gateway custom domain
            bucket: S3 bucket name
            key: S3 key path for the truststore
            file_path: Local file path to the truststore file
        """
        apigw = boto3.client("apigatewayv2")
        s3 = boto3.client("s3")

        # Upload the truststore file to S3
        try:
            with open(file_path, "rb") as f:
                response = s3.put_object(
                    Bucket=bucket,
                    Key=key,
                    Body=f.read(),
                    ContentType="application/x-pem-file",
                    ServerSideEncryption="AES256",
                )
            logger.info(f"Uploaded truststore to s3://{bucket}/{key}")
            logger.info(f"ETag: {response.get('ETag', 'N/A')}")
            logger.info(f"Version ID: {response.get('VersionId', 'N/A')}")
        except Exception as e:
            logger.error(f"Failed to upload truststore to S3: {e}")
            raise

        # Get the latest version ID
        try:
            versions = s3.list_object_versions(Bucket=bucket, Prefix=key)["Versions"]
            latest = sorted(versions, key=lambda v: v["LastModified"], reverse=True)[0]
            version_id = latest["VersionId"]
        except Exception as e:
            logger.error(f"Failed to get latest version ID: {e}")
            raise

        # Update API Gateway domain with new truststore version
        try:
            apigw.update_domain_name(
                DomainName=domain,
                MutualTlsAuthentication={
                    "TruststoreUri": f"s3://{bucket}/{key}",
                    "TruststoreVersion": version_id,
                },
            )
            logger.info(f"Updated {domain} to truststore version {version_id}")
        except Exception as e:
            logger.error(f"Failed to update API Gateway domain: {e}")
            raise

    def deploy(self) -> None:
        """Deploy certificates based on instance configuration."""
        logger.info("Starting certificate generation process...")

        # Step 1: Generate CA certificate
        logger.info("Step 1: Generating CA certificate...")
        ca_success, ca_crt_path, ca_key_path = generate_ca_certificate(
            self.cert_dir, self.ca_name
        )
        if not ca_success or ca_crt_path is None or ca_key_path is None:
            logger.error("Failed to generate CA certificate. Exiting.")
            sys.exit(1)

        # Step 2: Generate client certificate
        logger.info("Step 2: Generating client certificate...")
        client_success, client_crt_path, client_key_path = generate_client_certificate(
            self.cert_dir, ca_crt_path, ca_key_path, self.client_name
        )
        if not client_success or client_crt_path is None or client_key_path is None:
            logger.error("Failed to generate client certificate. Exiting.")
            sys.exit(1)

        # Step 3: Generate server certificate
        logger.info("Step 3: Generating server certificate...")
        server_success, _, _ = generate_server_certificate(
            self.cert_dir, ca_crt_path, ca_key_path, self.server_name
        )
        if not server_success:
            logger.error("Failed to generate server certificate. Exiting.")
            sys.exit(1)

        # Step 4: Create truststore of the CA certificate
        logger.info("Step 4: Creating truststore...")
        truststore_success = create_truststore(self.cert_dir, ca_crt_path)
        if not truststore_success:
            logger.error("Failed to create truststore. Exiting.")
            sys.exit(1)

        # Step 5: Create P12 bundle
        logger.info("Step 5: Creating P12 bundle...")
        p12_success, _ = create_p12_bundle(
            self.cert_dir, client_crt_path, client_key_path, self.p12_password
        )
        if not p12_success:
            logger.error("Failed to create P12 bundle. Exiting.")
            sys.exit(1)

        # Step 6: Copy to MCP directory for local development
        if self.copy_to_mcp:
            logger.info(
                "Step 6: Copying server certificates to calendar_mcp directory..."
            )
            copy_success = copy_server_certificates_to_mcp(
                self.cert_dir, self.script_dir
            )
            if not copy_success:
                logger.warning(
                    "Failed to copy server certificates to calendar_mcp directory"
                )

        # Step 7: Create environment script
        logger.info("Step 7: Creating environment script...")
        env_success = create_environment_script(
            self.cert_dir, self.secrets_dict, self.p12_password
        )
        if not env_success:
            logger.warning("Failed to create environment script")

        # Step 8: Cleanup (optional)
        if self.cleanup:
            logger.info("Step 8: Cleaning up intermediate files...")
            cleanup_intermediate_files(self.cert_dir)

        self._log_completion()

    def _log_completion(self) -> None:
        """Log completion information."""
        logger.info("Certificate generation completed successfully!")
        logger.info(f"All certificates are stored in: {self.cert_dir}")
        logger.info("Generated files:")
        logger.info("  - ca.crt, ca.key, ca.crt.b64 (CA certificate)")
        logger.info("  - client.crt, client.key (Client certificate)")
        logger.info("  - server.crt, server.key (Server certificate)")
        logger.info("  - truststore.pem (Truststore bundle)")
        logger.info("  - client.p12, client.p12.b64 (P12 bundle)")
        logger.info("  - set_env.sh (Environment script)")
        logger.info("  - append_to_zshrc.sh (Zshrc append script)")
        logger.info("")
        logger.info("To permanently add variables to ~/.zshrc:")
        logger.info("./certificates/append_to_zshrc.sh && source ~/.zshrc")


def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Generate certificates for mTLS authentication",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                                    # Generate with all defaults
  %(prog)s --ca-name MyCA --client-name my-client
  %(prog)s --no-copy-to-mcp --cleanup        # Don't copy to MCP, cleanup files
  %(prog)s --p12-password mypassword          # Use custom P12 password
  %(prog)s --action update_mtls_truststore --domain mcp.example.com --bucket my-bucket --key certs/truststore.pem --file-path certificates/truststore.pem
        """,
    )
    parser.add_argument(
        "--action",
        choices=["deploy", "update_mtls_truststore"],
        default="deploy",
        help="Action to perform: deploy certificates or update mTLS truststore (default: deploy)",
    )
    parser.add_argument(
        "--ca-name",
        default="CalendarMCPDevRootCA",
        help="Common name for CA certificate (default: CalendarMCPDevRootCA)",
    )
    parser.add_argument(
        "--client-name",
        default="agent-123",
        help="Common name for client certificate (default: agent-123)",
    )
    parser.add_argument(
        "--server-name",
        default="localhost",
        help="Common name for server certificate (default: localhost)",
    )
    parser.add_argument(
        "--p12-password",
        default=None,
        help="Password for P12 bundle (default: auto-generated random password)",
    )
    parser.add_argument(
        "--cleanup",
        action="store_true",
        default=False,
        help="Clean up intermediate files after generation (default: False)",
    )
    parser.add_argument(
        "--copy-to-mcp",
        action="store_true",
        help="Copy server certificates to calendar_mcp directory (default: True)",
    )
    parser.add_argument(
        "--no-copy-to-mcp",
        action="store_true",
        help="Do not copy server certificates to calendar_mcp directory (overrides --copy-to-mcp)",
    )

    # Arguments for update_mtls_truststore action
    parser.add_argument(
        "--domain",
        help="Domain name for mTLS truststore update (required for update_mtls_truststore action)",
    )
    parser.add_argument(
        "--bucket",
        default="mcp-truststore",
        help="S3 bucket name for truststore (default: mcp-truststore)",
    )
    parser.add_argument(
        "--key",
        default="certificates/truststore.pem",
        help="S3 key path for truststore (default: certificates/truststore.pem)",
    )
    parser.add_argument(
        "--file-path",
        default="certificates/truststore.pem",
        help="Local file path to truststore (default: certificates/truststore.pem)",
    )

    return parser.parse_args()


def main() -> None:
    """Main function to generate all certificates."""
    args = parse_arguments()

    if args.action == "deploy":
        # Extract arguments and pass to CertificateManager
        cert_manager = CertificateManager(
            ca_name=args.ca_name,
            client_name=args.client_name,
            server_name=args.server_name,
            p12_password=args.p12_password,
            copy_to_mcp=not args.no_copy_to_mcp,
            cleanup=args.cleanup,
        )
        cert_manager.deploy()

    elif args.action == "update_mtls_truststore":
        if not args.domain:
            logger.error("--domain is required for update_mtls_truststore action")
            sys.exit(1)

        cert_manager = CertificateManager()
        cert_manager.update_mtls_truststore(
            domain=args.domain,
            bucket=args.bucket,
            key=args.key,
            file_path=args.file_path,
        )


if __name__ == "__main__":
    main()
